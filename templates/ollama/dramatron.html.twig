{% extends 'base.html.twig' %}

{% block title %}Dramatron{% endblock %}
{% block header_title %}
    {{ block('title') }}
{% endblock %}

{% block content %}
    <form class="pure-form" x-data="dramatron('{{ ollama_api }}')">
        <div class="pure-g">
            <div class="pure-u-4-5">
                <fieldset>
                    <h2>Pitch</h2>
                    <textarea x-model="scenario.pitch" class="pure-input-1" rows="4"></textarea>
                    <button class="pure-button" x-bind:disabled="!scenario.pitch" x-on:click.prevent="generate">
                        Générer le prochain champ vide
                    </button>
                    <button class="pure-button" x-bind:disabled="!scenario.pitch" x-on:click.prevent="save">Sauver en local</button>
                    <button class="pure-button" x-bind:disabled="!!scenario.pitch" x-on:click.prevent="load">Charger en local</button>
                    <button class="pure-button" x-bind:disabled="!scenario.pitch" x-on:click.prevent="totalCreation">Effacer et tout générer à partir du pitch</button>
                    <h2>
                        Développement
                        <button class="pure-button" x-on:click.prevent="scenario.story=''; generate()"><i class="icon-spin3"></i></button>
                    </h2>
                    <textarea x-model="scenario.story" class="pure-input-1" rows="30"></textarea>
                    <template x-for="idx in [1,2,3,4,5]">
                        <section>
                            <h2>
                                <span x-text="'Acte ' + idx"></span>
                                <button class="pure-button" x-on:click.prevent="scenario['act' + idx]=''; generate()"><i class="icon-spin3"></i></button>
                            </h2>
                            <textarea x-model="scenario['act' + idx]" class="pure-input-1" rows="10"></textarea>
                        </section>
                    </template>
                </fieldset>
            </div>
            <aside class="pure-u-1-5">
                <fieldset>
                    <h2>
                        Personnages
                        <button class="pure-button" x-bind:disabled="!scenario.pitch" x-on:click.prevent="extractCharacter"><i class="icon-spin3"></i></button>
                    </h2>
                    <ul>
                        <template x-for="entry in scenario.character">
                            <li x-text="entry.name"></li>
                        </template>
                    </ul>
                    <h2>Décors</h2>
                    <ul>
                        <template x-for="entry in scenario.place">
                            <li x-text="entry.name"></li>
                        </template>
                    </ul>
                </fieldset>
            </aside>
        </div>
    </form>
{% endblock %}

{% block javascripts %}
    {{ parent() }}
    <script type="application/json" id="character-schema">
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "characters": {
      "description": "A list of characters mentionned in this fiction",
      "type": "array",
      "items": {
        "type": "object",
        "description": "A character extracted from this fiction"
        "properties": {
          "name": {
            "description": "Full name of the character",
            "type": "string"
          },
          "role": {
            "description": "Role of the character in this fiction (optional)",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "additionalProperties": true
      }
    }
  },
  "required": [
    "characters"
  ],
  "additionalProperties": true
}
    </script>
    <script type="application/json" id="init-payload">
        {{ payload|json_encode()|raw }}
    </script>
    <script type="module">
        import { Ollama } from 'ollama/browser';
        class Scenario {
            title = null
            pitch = null
            story = null
            act1 = null
            act2 = null
            act3 = null
            act4 = null
            act5 = null
            characterOutput = null
            character = []
            placeOutput = null
            place = []
        }

        Alpine.data('dramatron', url => ({
                ollama: null,
                scenario: null,

                init() {
                    this.scenario = new Scenario()
                    this.ollama = new Ollama({host: url})
                },

                async generate() {
                    const newGeneration = this.getStoryPayload()
                    console.log('new generation for', newGeneration.field)
                    await this.printAnswer(newGeneration.payload, newGeneration.field)
                },

                getDefaultPayload() {
                    let p = JSON.parse(document.getElementById('init-payload').textContent)
                    p.options.num_ctx = 30000

                    return p
                },

                getStoryPayload() {
                    if (!this.scenario.pitch) {
                        throw new Error('Pitch is empty, cannot generate anything without, at least, a pitch')
                    }

                    let payload = this.getDefaultPayload()
                    payload.messages[1].content = payload.messages[1].content
                            + this.scenario.pitch
                            + "\nDéveloppe ce synopsis en 5 actes"

                    // adding generated story to the train-of-thought. If it's empty, returning the payload for generation
                    if (this.scenario.story) {
                        payload.messages[2] = {role: 'assistant', content: this.scenario.story}
                    } else {
                        return {field: 'story', payload: payload}
                    }

                    // Adding the already-generated/filled acts (skipping empty acts) to the train-of-thought
                    for (let k = 1; k <= 5; k++) {
                        if (this.scenario['act' + k]) {
                            payload.messages.push(this.getQuestionForAct(k))
                            payload.messages.push({role: 'assistant', content: this.scenario['act' + k]})
                        }
                    }

                    // finding the first empty act and returning the payload with the question at the end
                    for (let k = 1; k <= 5; k++) {
                        const key = 'act' + k
                        if (!this.scenario[key]) {
                            payload.messages.push(this.getQuestionForAct(k))
                            return {field: key, payload: payload}
                        }
                    }

                    throw new Error('No empty field to ask the LLM to generate')
                },

                getQuestionForAct(n) {
                    return {role: 'user', content: `Développe sur 5 scènes, en incluant une scène d'action, l'acte ${n} de ton synopsis`}
                },

                async printAnswer(payload, field) {
                    // abort in any case
                    this.ollama.abort()

                    //re-init
                    this.scenario[field] = ''
                    const response = await this.ollama.chat(payload)

                    try {
                        for await (const part of response) {
                            this.scenario[field] = this.scenario[field].concat(part.message.content)
                            if (part.done === true) {
                                console.table({'prompt token count': part.prompt_eval_count, 'response token count': part.eval_count})
                            }
                        }
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log('The request has been aborted')
                        } else {
                            console.error('An error occurred:', error)
                        }
                    }
                },

                save() {
                    localStorage.setItem('dramatron', JSON.stringify(this.scenario))
                },

                load() {
                    this.scenario = JSON.parse(localStorage.getItem('dramatron'))
                },

                getQuestionForCharacter(schema, story) {
                    // thanks to https://thoughtbot.com/blog/get-consistent-data-from-your-llm-with-json-schema for this :
                    return `
Consider the following JSON Schema based on the 2020-12 specification:
\`\`\`json
${schema}
\`\`\`

This JSON Schema represents the format I want you to follow to generate your answer.
Now, generate a JSON object that will list all characters' names extracted from this story:
${story}

Based on all this information, generate a valid JSON object with list of characters' names. 
Optionaly, you can add the character's role if you can determine it.
`
                },

                async extractCharacter(event) {
                    const icon = event.currentTarget.getElementsByTagName('i')[0]
                    icon.classList.add('animate-spin')

                    let story = ''
                    for (let k = 1; k <= 5; k++) {
                        const key = 'act' + k
                        story = story.concat(this.scenario[key] + "\n")
                    }

                    const schema = document.getElementById('character-schema').textContent

                    let payload = this.getDefaultPayload()
                    payload.messages[1].content = this.getQuestionForCharacter(schema, story)
                    await this.printAnswer(payload, 'characterOutput')
                    // @todo Better handling bad json and bad format of json
                    const extract = this.extractJsonBlock(this.scenario.characterOutput)
                    this.scenario.character = []
                    for (const npc of extract.characters) {
                        this.scenario.character.push({name: npc.name})
                    }

                    icon.classList.remove('animate-spin')
                },

                extractJsonBlock(answer) {
                    const regex = /```json\n([^`]+)\n```/
                    let match;
                    // @todo Better handling bad json and bad format of json
                    if ((match = regex.exec(answer)) !== null) {
                        return JSON.parse(match[1])
                    }

                    throw new Error(answer + ' does not contains JSON code')
                },

                async totalCreation() {
                    // Reboot the scnario, just keeping the pitch
                    let reboot = new Scenario()
                    reboot.pitch = this.scenario.pitch
                    this.scenario = reboot
                    // regenerate the general story and the 5 acts
                    for(let k=0; k<6; k++) {
                        await this.generate()
                    }
                    // generate characters
                    await extractCharacter()
                }
            }))
    </script>
{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <style>
        .pure-u-4-5 > fieldset {
            margin-right: 2em;
        }

        fieldset > h2:first-child {
            margin-top: 0;
        }

        fieldset h2 .pure-button {
            font-size: 1rem;
            float: right;
        }
    </style>
{% endblock %}
