{% extends "base.html.twig" %}

{% block title %}YOLO{% endblock %}

{% block body %}
    <canvas id="renderCanvas">
    </canvas>
{% endblock %}

{% block javascripts %}
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script>
    <script type="module">
        const universe = {
            coulomb: 100,
            spring: 1,
            sphereRadius: 1,
            damping: 1
        }

        const adjacency = [
            [0, 1, 0, 0, 0],
            [0, 0, 1, 0, 0],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0]
        ]
        const size = adjacency.length

        // babylonjs
        const canvas = document.getElementById("renderCanvas") // Get the canvas element
        const engine = new BABYLON.Engine(canvas) // Generate the BABYLON 3D engine

        // Creates Scene object
        const scene = new BABYLON.Scene(engine)

        // Creates and positions a free camera for GM
        const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true)

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
            scene.render()
        })
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            engine.resize()
        })

        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.7;

        // enable physics in the scene with a gravity
        // initialize plugin
        const havokInstance = await HavokPhysics();
        // pass the engine to the plugin
        const hk = new BABYLON.HavokPlugin(true, havokInstance);
        scene.enablePhysics(new BABYLON.Vector3(0, 0, 0), hk);
        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        let sphere = []
        let sphereAggregate = []
        for (let idx of adjacency[0]) {
            // Our built-in 'sphere' shape.
            let mesh = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: universe.sphereRadius, segments: 16}, scene)
            mesh.position = new BABYLON.Vector3(Math.random() * size, Math.random() * size, Math.random() * size)
            let physic = new BABYLON.PhysicsAggregate(mesh, BABYLON.PhysicsShapeType.SPHERE, {mass: 1, restitution: 0.75}, scene);
            physic.body.setLinearDamping(universe.damping)
            sphere.push(mesh)
            sphereAggregate.push(physic)

            // label
            let label = new BABYLON.GUI.TextBlock()
            advancedTexture.addControl(label)
            label.text = "Sphere"
            label.color = "white"
            label.shadowColor = "black"
            label.shadowBlur = 4
            label.linkWithMesh(mesh);
        }

        let lines = []
        for (let source = 0; source < size; source++) {
            for (let target = source + 1; target < size; target++) {
                if (adjacency[source][target]) {
                    const options = {
                        points: [sphere[source].position, sphere[target].position],
                        updatable: true
                    }
                    if (lines[source] === undefined) {
                        lines[source] = []
                    }
                    lines[source][target] = BABYLON.MeshBuilder.CreateLines("lines" + source + '-' + target, options, scene);
                }
            }
        }

        scene.registerBeforeRender(function () {
            // physics of Vertices
            for (let source = 0; source < size; source++) {
                for (let target = source + 1; target < size; target++) {
                    let delta = sphere[target].position.subtract(sphere[source].position)
                    let dist = delta.length()
                    let result = -universe.coulomb / Math.pow(dist, 2)
                    if (adjacency[source][target]) {
                        result += dist * universe.spring
                    }
                    delta.normalize()
                    sphereAggregate[source].body.applyForce(
                            delta.scale(result),
                            sphere[source].absolutePosition
                            )
                    sphereAggregate[target].body.applyForce(
                            delta.scale(-result),
                            sphere[target].absolutePosition
                            )
                }
            }
            // updating Edges
            for (let source = 0; source < size; source++) {
                for (let target = source + 1; target < size; target++) {
                    if (adjacency[source][target]) {
                        const options = {
                            points: [sphere[source].position, sphere[target].position],
                            instance: lines[source][target]
                        }
                        lines[source][target] = BABYLON.MeshBuilder.CreateLines("lines" + source + '-' + target, options, scene);
                    }
                }
            }
        })
    </script>
{% endblock %}


{% block stylesheets %}
    {{ parent() }}
    <style>
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
{% endblock %}
