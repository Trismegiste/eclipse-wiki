{# Session cache of broadcasted pictures #}
{% extends "base.html.twig" %}

{% block title %}Broadcasted pictures{% endblock %}
{% block header_title %}{{ block('title') }}{% endblock %}

{% block content %}
    {{ form(form) }}
{% endblock %}

{% block _xform_picture_row %}
    <script type="application/json" id="{{ form.vars.id }}">
        {{ form.vars.choices|json_encode()|raw }}
    </script>
    <section class="mosaic" x-data="gallery('{{ form.vars.id }}')" x-id="['pic']"
             x-on:dragenter.prevent="gapEnter"
             x-on:dragover.prevent="gapOver"
             x-on:dragleave.prevent="gapLeave"
             x-on:drop.prevent="dropPicture">
        <template x-for="(child, idx) in listing" :key="child.value">
            <div class="flow" x-bind:data-index="idx">
                <input x-bind:id="$id('pic', idx)" type="checkbox" name="{{ form.vars.full_name }}[]" x-bind:value="child.value" checked="checked"/>
                <label x-bind:for="$id('pic', idx)">
                    <img x-bind:src="'/session/broadcasted-picture/' + child.value"
                         x-bind:data-index="idx"
                         draggable="true"
                         x-on:dragstart="pictureDragStart"
                         x-on:dragend="pictureDragEnd"/>
                </label>
            </div>
        </template>
    </section>
    <script type="module">
        Alpine.data('gallery', (modelId) => ({
                listing: [],

                init() {
                    this.listing = JSON.parse(document.getElementById(modelId).textContent)
                },

                pictureDragStart(event) {
                    event.dataTransfer.setData("text/plain", this.$el.dataset.index)
                    event.dataTransfer.effectAllowed = "move";
                    event.target.classList.add("dragging")
                },

                pictureDragEnd(event) {
                    event.target.classList.remove("dragging")
                },

                gapEnter(event) {
                },

                gapOver(event) {
                    if (event.currentTarget === event.target) {
                        let around = this.getChildrenAround(event.currentTarget.children, event.clientX, event.clientY)
                        if (around.childOnTheRight !== null && around.childOnTheLeft !== null) {
                            around.childOnTheRight.classList.add('dropzone-hilite-right')
                            around.childOnTheLeft.classList.add('dropzone-hilite-left')
                        } else {
                            this.removeHilite()
                        }
                    } else {
                        this.removeHilite()
                    }
                },

                removeHilite() {
                    for (let child of this.$el.children) {
                        child.classList.remove('dropzone-hilite-left')
                        child.classList.remove('dropzone-hilite-right')
                    }
                },

                gapLeave(event) {
                },

                dropPicture(event) {
                    if (event.target.nodeName === 'SECTION') {
                        let around = this.getChildrenAround(event.currentTarget.children, event.clientX, event.clientY)
                        if (around.childOnTheRight !== null && around.childOnTheLeft !== null) {
                            const left = parseInt(around.childOnTheLeft.dataset.index)
                            const right = parseInt(around.childOnTheRight.dataset.index)
                            const source = parseInt(event.dataTransfer.getData("text"))

                            if (left === (right - 1)) {
                                let dragged = this.listing[source]
                                this.listing[source] = null
                                this.listing.splice(right, 0, dragged)
                                for (const [idx, entry] of this.listing.entries()) {
                                    if (entry === null) {
                                        this.listing.splice(idx, 1)
                                    }
                                }
                                this.removeHilite()
                            }
                        }
                    }
                },

                getChildrenAround(children, x, y) {
                    // search for child before the cursor
                    let childOnTheRight = null
                    for (let child of children) {
                        let rect = child.getBoundingClientRect()
                        if ((y >= rect.top) && (y <= rect.bottom)) {
                            if (x < rect.left) {
                                childOnTheRight = child
                                break
                            }
                        }
                    }
                    // search for child after the cursor
                    let childOnTheLeft = null
                    for (let idx = children.length - 1; idx >= 0; idx--) {
                        let child = children[idx]
                        let rect = child.getBoundingClientRect()
                        if ((y >= rect.top) && (y <= rect.bottom)) {
                            if (x > rect.right) {
                                childOnTheLeft = child
                                break
                            }
                        }
                    }

                    return {childOnTheRight, childOnTheLeft}
                }
            }))
    </script>
{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <style>
        .mosaic {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(8, 1fr);
        }

        .mosaic img {
            object-fit: contain;
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .mosaic label {
            display: block;
        }

        .mosaic input {
            display: none;
        }

        .mosaic input:not(:checked) + label img {
            filter: grayscale(0.8) blur(2px) opacity(50%);
        }

        .dragging {
            filter: sepia(100%) saturate(200%);
        }

        .dropzone-hilite-left img {
            object-position: -2em;
        }

        .dropzone-hilite-right img {
            object-position: 2em;
        }
        .mosaic label {
            margin: 0;
        }
    </style>
{% endblock %}
