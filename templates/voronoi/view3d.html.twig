{% extends "base.html.twig" %}

{% block content %}
    <canvas id="renderCanvas"></canvas>
    {% endblock %}

{% block javascripts %}
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        const canvas = document.getElementById("renderCanvas") // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true) // Generate the BABYLON 3D engine
        const wallHeight = 1.7

        const createScene = function () {
            // Creates a basic Babylon Scene object
            const scene = new BABYLON.Scene(engine)
            // Set gravity for the scene (G force like, on Y-axis)
            scene.gravity = new BABYLON.Vector3(0, -0.9, 0);
            // Enable Collisions
            scene.collisionsEnabled = true;

            // Creates and positions a free camera
            var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 2, -0.5), scene);
            camera.setTarget(new BABYLON.Vector3(0, 2, -1));
            camera.attachControl(canvas, true);
            camera.minZ = 0.3;
            // Then apply collisions and gravity to the active camera
            camera.checkCollisions = true;
            camera.applyGravity = true;
            //Set the ellipsoid around the camera (e.g. your player's size)
            camera.ellipsoid = new BABYLON.Vector3(0.1, wallHeight / 3, 0.1);

            // Creates a light, aiming 0,1,0 - to the sky
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene)
            // Dim the light a small amount - 0 to 1
            light.intensity = 0.9

            // Templates
            let textureKey = ['default', 'cluster-sleep', 'cluster-industry', 'cluster-park']
            // Ground templates
            textureKey.forEach((key) => {
                const tile = BABYLON.MeshBuilder.CreateDisc("hexagon-" + key, {tessellation: 6, radius: 2 / 3 - 0.01}, scene)
                tile.rotation.z = Math.PI / 6
                tile.rotation.x = Math.PI / 2
                tile.isVisible = false

                const myMaterial = new BABYLON.StandardMaterial('mat-ground-' + key, scene)
                myMaterial.diffuseTexture = new BABYLON.Texture("/texture/habitat/ground/" + key + ".webp", scene)
                tile.material = myMaterial
            })

            // selector
            const groundSelector = BABYLON.MeshBuilder.CreateDisc("selector-ground", {tessellation: 6, radius: 2 / 3}, scene)
            groundSelector.rotation.z = Math.PI / 6
            groundSelector.rotation.x = Math.PI / 2
            groundSelector.position.y = 0.01
            groundSelector.isVisible = false

            // Wall templates
            textureKey.forEach((key) => {
                const wall = BABYLON.MeshBuilder.CreatePlane("wall-" + key, {width: 2 / 3, height: wallHeight})
                wall.position.y = wallHeight / 2
                wall.position.x = 2 / 3 * Math.cos(Math.PI / 6)
                wall.rotation.y = Math.PI / 2
                wall.isVisible = false

                const myMaterial = new BABYLON.StandardMaterial('mat-wall-' + key, scene)
                myMaterial.diffuseTexture = new BABYLON.Texture("/texture/habitat/wall/" + key + ".webp", scene)
                wall.material = myMaterial
            })

            return scene
        }

        BABYLON.SceneLoader.RegisterPlugin({
            extensions: ".battlemap",
            importMesh: function (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons) {
                return true
            },
            loadAssets(scene, data, rootUrl) {
                var container = new AssetContainer(scene)
                return container
            },
            load: function (scene, data, rootUrl) {
                const battlemap = JSON.parse(data)
                const layer = scene.getHighlightLayerByName('highlighting')

                battlemap.grid.forEach((cell, k) => {
                    const ground = scene.getMeshByName('hexagon-' + cell.obj.template).createInstance("ground" + k)
                    ground.position.x = cell.x
                    ground.position.z = -cell.y
                    ground.checkCollisions = true

                    ground.actionManager = new BABYLON.ActionManager(scene);
                    ground.actionManager.registerAction(
                            new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, (e) => {
                                const selector = scene.getMeshByName('selector-ground')
                                const current = e.meshUnderPointer
                                selector.isVisible = true
                                selector.position.x = current.position.x
                                selector.position.z = current.position.z
                            })
                            )

                    for (let dir = 0; dir < 6; dir++) {
                        if (cell.obj.wall[dir]) {
                            const handle = new BABYLON.TransformNode("handle" + k + '-' + dir)
                            const tmpWall = scene.getMeshByName('wall-' + cell.obj.template).createInstance("wall-" + k + '-' + dir)
                            tmpWall.parent = handle
                            //tmpWall.checkCollisions = true
                            handle.rotation.y = -dir * Math.PI / 3
                            handle.position.x = cell.x
                            handle.position.z = -cell.y
                        }
                    }
                })

                return true
            }
        })

        const scene = createScene() //Call the createScene function
        BABYLON.SceneLoader.Append("/voronoi/babylon/", "{{ place.pk }}.battlemap", scene, function (scene) {})

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
            scene.render()
        })
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            engine.resize()
        })
    </script>
{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <style>
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
{% endblock %}
