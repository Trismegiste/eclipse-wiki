{# Custom rendering for tree with autocompleted wikitext links #}
{% block wiki_tree_widget %}
    <div x-data="arbre" class="timeline-tree">
        {{ form_widget(form) }}
        <template x-for="(node, index) in tree.getFlatList()" :key="index + node.title">
            <div class="pure-g">
                <div class="pure-u" x-bind:style="{width: node.level*5 + '%'}"></div>
                <div class="pure-u" x-bind:style="{width: (100-node.level*5) + '%'}">
                    <template x-if="node.parent !== null">
                        <div class="dropzone"
                             x-on:dragenter="dropZoneEnter"
                             x-on:dragleave="dropZoneLeave"
                             x-on:dragover="dropZoneOver"
                             x-on:drop="moveNodeBefore"
                             x-bind:data-index="index">
                        </div>
                    </template>
                    <div class="node-content" x-data="nodeAutocomplete">
                        <span x-text="node.title"
                              x-show="editingNode !== index"
                              x-bind:class="{'finished-node': node.finished}"
                              x-bind:draggable="node.parent !== null"
                              x-on:dragstart="nodeDragStart"
                              x-on:dragend="nodeDragEnd"
                              x-on:dragenter="nodeEnter"
                              x-on:dragleave="nodeLeave"
                              x-on:dragover="dropZoneOver"
                              x-on:drop="appendNode"
                              x-bind:data-index="index"></span>
                        <textarea x-show="editingNode === index"
                                  x-ref="editor"
                                  x-model="content"
                                  x-on:keyup="editKeyUp"></textarea>
                        <template x-if="open">
                            <select class="autocomplete-combobox" x-bind:style="caretPos" size="10"
                                    x-model="selected"
                                    x-on:click="choose"
                                    x-on:blur="open=false"
                                    x-on:keyup="comboKeyUp">
                                <template x-for="item in result" :key="item['value']">
                                    <option x-bind="item"></option>
                                </template>
                            </select>
                        </template>
                        <button class="pure-button button-write"
                                x-show="editingNode === index"
                                x-on:click.prevent="confirmEditNode"><i class="icon-edit"></i></button>
                        <button class="pure-button button-delete"
                                x-show="editingNode === index"
                                x-on:click.prevent="cancelEditNode"><i class="icon-edit"></i></button>
                        <button class="pure-button"
                                x-show="editingNode !== index"
                                x-on:click.prevent="editNode"
                                x-bind:data-index="index"
                                x-bind:disabled="node.parent === null"><i class="icon-edit"></i></button>
                        <button class="pure-button"
                                x-on:click.prevent="appendNewChild"
                                x-bind:data-index="index"><i class="icon-newchild"></i></button>
                        <button class="pure-button"
                                x-bind:disabled="node.parent === null"
                                x-on:click.prevent="deleteNode"
                                x-bind:data-index="index"><i class="icon-trash-empty"></i></button>
                        <button class="pure-button"
                                x-on:click.prevent="checkNode"
                                x-bind:data-index="index"><i class="icon-check"></i></button>
                    </div>
                    <template x-if="node.parent !== null">
                        <div class="dropzone"
                             x-on:dragenter="dropZoneEnter"
                             x-on:dragleave="dropZoneLeave"
                             x-on:dragover="dropZoneOver"
                             x-on:drop="moveNodeAfter"
                             x-bind:data-index="index">
                        </div>
                    </template>
                </div>
            </div>
        </template>
    </div>

    <script type="module">
        import { TimelineTree } from 'timeline-tree';
        import buildWikitextClosure from 'wikitext';

        let strategy = [
            {
                pattern: /\[\[([^\]]+)$/,
                url: '{{ path('app_vertexcrud_search') }}?q=',
                boundAttr: (entry) => ({
                        ['x-text'] () {
                            return entry
                        }
                    }),
                replace: (found) => {
                    return `[[${found}]]`
                }
            }
        ]

        Alpine.data('arbre', () => ({
                tree: null,
                editingNode: null,

                init() {
                    this.tree = Object.assign(new TimelineTree(), JSON.parse(this.$refs.wikitree.value))
                },

                nodeDragStart(event) {
                    event.dataTransfer.setData("text/plain", this.$el.dataset.index)
                    event.dataTransfer.effectAllowed = "move";
                    event.target.classList.add("dragging")
                },

                nodeDragEnd(event) {
                    event.target.classList.remove("dragging")
                },

                dropZoneEnter(event) {
                    event.preventDefault()
                    event.target.classList.add("dropzone-hilite")
                },

                dropZoneLeave(event) {
                    event.preventDefault()
                    event.target.classList.remove("dropzone-hilite")
                },

                nodeEnter(event) {
                    event.preventDefault()
                    event.target.classList.add("parent-hilite")
                },

                nodeLeave(event) {
                    event.preventDefault()
                    event.target.classList.remove("parent-hilite")
                },

                dropZoneOver(event) {
                    event.preventDefault()
                },

                moveNodeBefore(event) {
                    event.preventDefault()
                    let source = event.dataTransfer.getData("text")
                    let target = this.$el.dataset.index
                    this.tree.moveNodeBefore(parseInt(source), parseInt(target))
                    event.target.classList.remove("dropzone-hilite")
                },

                moveNodeAfter(event) {
                    event.preventDefault()
                    let source = event.dataTransfer.getData("text")
                    let target = this.$el.dataset.index
                    this.tree.moveNodeAfter(parseInt(source), parseInt(target))
                    event.target.classList.remove("dropzone-hilite")
                },

                appendNode(event) {
                    event.preventDefault()
                    let source = event.dataTransfer.getData("text")
                    let target = this.$el.dataset.index
                    this.tree.appendNode(parseInt(source), parseInt(target))
                    event.target.classList.remove("parent-hilite")
                },

                checkNode(event) {
                    let source = this.$el.dataset.index
                    this.tree.flipNode(parseInt(source))
                },

                appendNewChild(event) {
                    let source = this.$el.dataset.index
                    this.tree.appendNewChild(parseInt(source), 'New child')
                },

                deleteNode(event) {
                    let state = this.$el.dataset
                    if (state.alive === 'true') {
                        this.tree.deleteNode(parseInt(state.index))
                    } else {
                        document.querySelectorAll('button[data-alive=true]').forEach(elem => {
                            elem.dataset.alive = 'false'
                        })
                        state.alive = 'true'
                    }
                },

                editNode(event) {
                    let source = this.$el.dataset.index
                    this.editingNode = parseInt(source)
                    let flatten = this.tree.getFlatList()
                    this.content = flatten[this.editingNode].node.data.title
                    this.$nextTick(() => {
                        this.$refs.editor.focus()
                    })
                },

                confirmEditNode(event) {
                    let flatten = this.tree.getFlatList()
                    flatten[this.editingNode].node.data.title = this.content
                    this.editingNode = null
                },

                cancelEditNode(event) {
                    this.editingNode = null
                },
                
                dumpTree(event) {
                    this.$refs.wikitree.value = JSON.stringify(this.tree)
                }

            }))

        Alpine.data('nodeAutocomplete', buildWikitextClosure(strategy))
    </script>
{% endblock %}
