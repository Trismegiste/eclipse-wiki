{# Custom rendering for tree with autocompleted wikitext links #}
{% block wiki_tree_widget %}
    {{ form_widget(form) }}
    <div id="{{ form.vars.id }}_tree" class="tree_widget"></div>
    <textarea id="{{ form.vars.id }}_edit" class="pure-input-1"></textarea>
    <script>
        window.addEventListener('load', () => {
            if (typeof SortableTree === "undefined") {
                throw new Error('SortableTree is not included')
            }

            const hiddenTree = document.getElementById('{{ form.vars.id }}')
            const editArea = document.getElementById('{{ form.vars.id }}_edit')
            const nodeData = [{{ form.vars.data|raw }}]
            let currentlyEditedNode = null

            const tree = new SortableTree({
                nodes: nodeData,
                element: document.getElementById('{{ form.vars.id }}_tree'),
                initCollapseLevel: 4,
                //  stateId: 'some-tree',
                renderLabel: (data) => {
                    return `<input type="checkbox"/>
                                <span>${data.title}</span>
                                <button class="pure-button"><i class="icon-edit"></i></button>
                                <button class="pure-button"><i class="icon-newchild"></i></button>
                                <button class="pure-button"><i class="icon-trash-empty"></i></button>`
                },
                onChange: ({ nodes, movedNode, srcParentNode, targetParentNode }) => {
                    hiddenTree.value = JSON.stringify(dumpTree(nodes[0]))
                },
                onClick: (event, node) => {
                    // node.label.querySelector('span').innerHTML += ' yolo'
                    // node.data.title += ' yolo'
                }
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-newchild').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    let node = button.parentElement.parentElement
                    let newChild = {data: {title: 'New child', finished: false}, nodes: []}
                    let originalNode = backtrackOriginalNodeWithData(nodeData[0], node.data)  // mauvaise idée d'utiliser nodeData car il n'est pas mis à jour lors du SortableTree::onChange
                    originalNode.nodes.push(newChild)
                    hiddenTree.value = JSON.stringify(nodeData[0])
                })
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-trash-empty').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    let node = button.parentElement.parentElement
                    let parentNode = node.parentElement.parentElement
                    let originalNode = backtrackOriginalNodeWithData(nodeData[0], node.data)
                    let originalParentNode = backtrackOriginalNodeWithData(nodeData[0], parentNode.data)
                    let idx = originalParentNode.nodes.indexOf(originalNode)
                    originalParentNode.nodes.splice(idx, 1)
                    hiddenTree.value = JSON.stringify(nodeData[0])
                })
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-edit').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    event.preventDefault()
                    let node = button.parentElement.parentElement
                    editArea.hidden = false
                    editArea.focus()
                    editArea.innerHTML = node.data.title
                    currentlyEditedNode = node
                })
            })

            editArea.addEventListener('blur', event => {
                currentlyEditedNode.data.title = editArea.value
                currentlyEditedNode.label.querySelector('span').innerHTML = editArea.value
                hiddenTree.value = JSON.stringify(nodeData[0])
                editArea.value = ''
                editArea.hidden = true
                currentlyEditedNode = null
            })

            function dumpTree(elem) {
                let dump = {data: tree.getNode(elem.id).data, nodes: []}
                for (let child of elem.subnodes) {
                    dump.nodes.push(dumpTree(child))
                }

                return dump
            }

            function backtrackOriginalNodeWithData(node, data) {
                if (node.data === data) {
                    return node
                }

                for (let child of node.nodes) {
                    let found = backtrackOriginalNodeWithData(child, data)
                    if (found !== null) {
                        return found
                    }
                }

                return null
            }
        })
    </script>
{% endblock %}
