{# Custom rendering for tree with autocompleted wikitext links #}
{% block wiki_tree_widget %}
    {{ form_widget(form) }}

    <div x-data="arbre">
        <template x-for="(node, index) in tree.getFlatList()" :key="node.title">
            <div class="pure-g">
                <div class="pure-u" x-bind:style="{width: node.level*5 + '%'}"></div>
                <div class="pure-u" x-bind:style="{width: (100-node.level*5) + '%'}">
                    <div class="dropzone"
                         x-on:dragenter="dropZoneEnter"
                         x-on:dragleave="dropZoneLeave"
                         x-on:dragover="dropZoneOver"
                         x-on:drop="dropNode"
                         x-bind:data-index="index">
                    </div>
                    <div class="node-content" draggable="true"
                         x-on:dragstart="nodeDragStart"
                         x-on:dragend="nodeDragEnd"
                         x-bind:data-index="index">
                        <span x-text="node.title"></span>
                    </div>
                    <div class="dropzone"
                         x-on:dragenter="dropZoneEnter"
                         x-on:dragleave="dropZoneLeave"
                         x-on:dragover="dropZoneOver"
                         x-on:drop="dropNode"
                         x-bind:data-index="index">
                    </div>
                </div>
            </div>
        </template>
    </div>

    <style>
        .dropzone {
            height: 4px;
        }
        .dropzone-hilite {
            background-color: green;
            height: 1em;
        }
        .node-content {
            border: 2px solid #333;
            padding: 0.3em;
            border-radius: 0.3em;
        }
        .dragging {
            background-color: lightgreen;
        }
    </style>

    <div id="{{ form.vars.id }}_tree" class="tree_widget"></div>
    <textarea id="{{ form.vars.id }}_edit" class="pure-input-1" hidden="true"></textarea>
    <script type="module">
        import { TimelineTree } from 'timeline-tree';
        const newTree = Object.assign(new TimelineTree(), {{ form.vars.data|raw }})

        Alpine.data('arbre', () => ({
                tree: newTree,

                nodeDragStart(event) {
                    event.dataTransfer.setData("text/plain", this.$el.dataset.index)
                    event.dataTransfer.effectAllowed = "move";
                    event.target.classList.add("dragging")
                },

                nodeDragEnd(event) {
                    this.draggedNode = null
                    event.target.classList.remove("dragging")
                },

                dropZoneEnter(event) {
                    event.preventDefault()
                    event.target.classList.add("dropzone-hilite")
                },

                dropZoneOver(event) {
                    event.preventDefault()
                },

                dropZoneLeave(event) {
                    event.preventDefault()
                    event.target.classList.remove("dropzone-hilite")
                },

                dropNode(event) {
                    event.preventDefault()
                    let source = event.dataTransfer.getData("text")
                    let target = this.$el.dataset.index
                    this.tree.moveNodeAfter(parseInt(source), parseInt(target))
                }

            }))

        import SortableTree from 'sortable-tree';
        const hiddenTree = document.getElementById('{{ form.vars.id }}')
        const editArea = document.getElementById('{{ form.vars.id }}_edit')
        let nodeData = [{{ form.vars.data|raw }}][0]
        let currentlyEditedNode = null

        const tree = new SortableTree({
            nodes: [nodeData],
            element: document.getElementById('{{ form.vars.id }}_tree'),
            initCollapseLevel: 4,
        {% if form.vars.state_key is defined %}
                stateId: '{{ form.vars.state_key }}',
        {% endif %}
                renderLabel: (data) => {
                    let state = data.finished ? 'finished-node' : ''
                    return `<span class="${state}">${data.title}</span>
                                <button class="pure-button"><i class="icon-edit"></i></button>
                                <button class="pure-button"><i class="icon-newchild"></i></button>
                                <button class="pure-button"><i class="icon-trash-empty"></i></button>
                                <button class="pure-button"><i class="icon-check"></i></button>`
                },
                onChange: ({ nodes, movedNode, srcParentNode, targetParentNode }) => {
                    nodeData = dumpTree(nodes[0])
                    hiddenTree.value = JSON.stringify(nodeData)
                }
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-newchild').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    let node = button.parentElement.parentElement
                    let newChild = {data: {title: 'New child', finished: false}, nodes: []}
                    let originalNode = backtrackOriginalNodeWithData(nodeData, node.data)
                    originalNode.nodes.push(newChild)
                    hiddenTree.value = JSON.stringify(nodeData)
                })
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-trash-empty').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    if (button.dataset.alive === 'true') {
                        let node = button.parentElement.parentElement
                        let parentNode = node.parentElement.parentElement
                        let originalNode = backtrackOriginalNodeWithData(nodeData, node.data)
                        let originalParentNode = backtrackOriginalNodeWithData(nodeData, parentNode.data)
                        let idx = originalParentNode.nodes.indexOf(originalNode)
                        originalParentNode.nodes.splice(idx, 1)
                        hiddenTree.value = JSON.stringify(nodeData)
                    } else {
                        button.dataset.alive = 'true'
                        event.preventDefault()
                    }
                })
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-edit').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    event.preventDefault()
                    let node = button.parentElement.parentElement
                    node.append(editArea)
                    editArea.hidden = false
                    editArea.focus()
                    editArea.value = node.data.title
                    currentlyEditedNode = node
                })
            })

            editArea.addEventListener('blur', event => {
                currentlyEditedNode.data.title = editArea.value.trim()
                currentlyEditedNode.label.querySelector('span').innerHTML = editArea.value.trim()
                hiddenTree.value = JSON.stringify(nodeData)
                editArea.value = ''
                editArea.hidden = true
                currentlyEditedNode.label.querySelector('button').focus()
                currentlyEditedNode = null
            })

            document.querySelectorAll('#{{ form.vars.id }}_tree i.icon-check').forEach(elem => {
                let button = elem.parentElement
                button.addEventListener('click', event => {
                    let node = button.parentElement.parentElement
                    let originalNode = backtrackOriginalNodeWithData(nodeData, node.data)
                    originalNode.data.finished = !originalNode.data.finished
                    hiddenTree.value = JSON.stringify(nodeData)
                })
            })

            function dumpTree(elem) {
                let dump = {data: tree.getNode(elem.id).data, nodes: []}
                for (let child of elem.subnodes) {
                    dump.nodes.push(dumpTree(child))
                }

                return dump
            }

            function backtrackOriginalNodeWithData(node, data) {
                if (node.data === data) {
                    return node
                }

                for (let child of node.nodes) {
                    let found = backtrackOriginalNodeWithData(child, data)
                    if (found !== null) {
                        return found
                    }
                }

                return null
            }

            // copy-pasted from wikitext.html.twig but it's far more simple than create a compound form.
            // And furthemore, I don't need the same behavior since images are not allowed in node title.
            // The other way is to create a global javascript variable to store the link strategy but the route is generated with twig
            // "Not great, not terrible"
            if (typeof Textcomplete === "undefined") {
                throw new Error('Yuku TextComplete is required')
            }

            let Textarea = Textcomplete.editors.Textarea
            let editor = new Textarea(editArea)
            let textcomplete = new Textcomplete(editor)
            textcomplete.register([{
                    // Link strategy for Vertex
                    match: /(.*)\[\[([^\]]+)$/,
                    search: function (term, callback) {
                        fetch('{{ path('app_vertexcrud_search') }}' + '?q=' + term)
                                .then((response) => {
                                    return response.json()
                                })
                                .then((data) => {
                                    callback(data)
                                })
                    },
                    replace: function (value) {
                        return '$1[[' + value + ']] '
                    }
                }])
    </script>
{% endblock %}
