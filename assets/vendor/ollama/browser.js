/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/ollama@0.5.7/dist/browser.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var e="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};function t(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}var n=t,o=r;function s(e){if(n===setTimeout)return setTimeout(e,0);if((n===t||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}"function"==typeof e.setTimeout&&(n=setTimeout),"function"==typeof e.clearTimeout&&(o=clearTimeout);var a,i=[],c=!1,l=-1;function h(){c&&a&&(c=!1,a.length?i=a.concat(i):l=-1,i.length&&u())}function u(){if(!c){var e=s(h);c=!0;for(var t=i.length;t;){for(a=i,i=[];++l<t;)a&&a[l].run();l=-1,t=i.length}a=null,c=!1,function(e){if(o===clearTimeout)return clearTimeout(e);if((o===r||!o)&&clearTimeout)return o=clearTimeout,clearTimeout(e);try{return o(e)}catch(t){try{return o.call(null,e)}catch(t){return o.call(this,e)}}}(e)}}function f(e,t){this.fun=e,this.array=t}f.prototype.run=function(){this.fun.apply(null,this.array)};function d(){}var m=d,p=d,w=d,g=d,y=d,b=d,v=d;var T=e.performance||{},$=T.now||T.mozNow||T.msNow||T.oNow||T.webkitNow||function(){return(new Date).getTime()};var S=new Date;var j={nextTick:function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];i.push(new f(e,t)),1!==i.length||c||s(u)},title:"browser",browser:!0,env:{},argv:[],version:"",versions:{},on:m,addListener:p,once:w,off:g,removeListener:y,removeAllListeners:b,emit:v,binding:function(e){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(e){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(e){var t=.001*$.call(T),r=Math.floor(t),n=Math.floor(t%1*1e9);return e&&(r-=e[0],(n-=e[1])<0&&(r--,n+=1e9)),[r,n]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-S)/1e3}};var E=Object.defineProperty,q=(e,t,r)=>(((e,t,r)=>{t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);class R extends Error{constructor(e,t){super(e),this.error=e,this.status_code=t,this.name="ResponseError",Error.captureStackTrace&&Error.captureStackTrace(this,R)}}class C{constructor(e,t,r){q(this,"abortController"),q(this,"itr"),q(this,"doneCallback"),this.abortController=e,this.itr=t,this.doneCallback=r}abort(){this.abortController.abort()}async*[Symbol.asyncIterator](){for await(const e of this.itr){if("error"in e)throw new Error(e.error);if(yield e,e.done||"success"===e.status)return void this.doneCallback()}throw new Error("Did not receive done or success response in stream.")}}const k=async e=>{if(e.ok)return;let t=`Error ${e.status}: ${e.statusText}`,r=null;if(e.headers.get("content-type")?.includes("application/json"))try{r=await e.json(),t=r.error||t}catch(e){console.log("Failed to parse error response as JSON")}else try{console.log("Getting text from response");t=await e.text()||t}catch(e){console.log("Failed to get text from error response")}throw new R(t,e.status)};const x=async(e,t,r={})=>{const n={"Content-Type":"application/json",Accept:"application/json","User-Agent":`ollama-js/0.5.7 (${"undefined"!=typeof window&&window.navigator?`${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`:void 0!==j?`${j.arch} ${j.platform} Node.js/${j.version}`:""})`};return r.headers||(r.headers={}),r.headers={...n,...r.headers},e(t,r)},N=async(e,t)=>{const r=await x(e,t);return await k(r),r},O=async(e,t,r,n)=>{const o=null===(s=r)||"object"!=typeof s||Array.isArray(s)?r:JSON.stringify(r);var s;const a=await x(e,t,{method:"POST",body:o,signal:n?.signal});return await k(a),a};var A=Object.defineProperty,L=(e,t,r)=>(((e,t,r)=>{t in e?A(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r);let D=class{constructor(e){L(this,"config"),L(this,"fetch"),L(this,"ongoingStreamedRequests",[]),this.config={host:""},e?.proxy||(this.config.host=(e=>{if(!e)return"http://127.0.0.1:11434";let t=e.includes("://");e.startsWith(":")&&(e=`http://127.0.0.1${e}`,t=!0),t||(e=`http://${e}`);const r=new URL(e);let n=r.port;n||(n=t?"https:"===r.protocol?"443":"80":"11434");let o=`${r.protocol}//${r.hostname}:${n}${r.pathname}`;return o.endsWith("/")&&(o=o.slice(0,-1)),o})(e?.host??"http://127.0.0.1:11434")),this.fetch=e?.fetch||this.getFetch()}getFetch(){if("undefined"!=typeof window&&window.fetch)return window.fetch.bind(window);if(void 0!==e&&e.fetch)return e.fetch;try{return require("node-fetch")}catch(e){throw console.error("Failed to import node-fetch:",e),new Error("Fetch is not available. Please provide a fetch implementation in the config.")}}abort(){for(const e of this.ongoingStreamedRequests)e.abort();this.ongoingStreamedRequests.length=0}async processStreamableRequest(e,t){t.stream=t.stream??!1;const r=`${this.config.host}/api/${e}`;if(t.stream){const e=new AbortController,n=await O(this.fetch,r,t,{signal:e.signal});if(!n.body)throw new Error("Missing body");const o=async function*(e){const t=new TextDecoder("utf-8");let r="";const n=e.getReader();for(;;){const{done:e,value:o}=await n.read();if(e)break;r+=t.decode(o);const s=r.split("\n");r=s.pop()??"";for(const e of s)try{yield JSON.parse(e)}catch(t){console.warn("invalid json: ",e)}}for(const e of r.split("\n").filter((e=>""!==e)))try{yield JSON.parse(e)}catch(t){console.warn("invalid json: ",e)}}(n.body),s=new C(e,o,(()=>{const e=this.ongoingStreamedRequests.indexOf(s);e>-1&&this.ongoingStreamedRequests.splice(e,1)}));return this.ongoingStreamedRequests.push(s),s}const n=await O(this.fetch,r,t);return await n.json()}async encodeImage(e){if("string"!=typeof e){const t=new Uint8Array(e);let r="";const n=t.byteLength;for(let e=0;e<n;e++)r+=String.fromCharCode(t[e]);return btoa(r)}return e}async generate(e){return e.images&&(e.images=await Promise.all(e.images.map(this.encodeImage.bind(this)))),this.processStreamableRequest("generate",e)}async chat(e){if(e.messages)for(const t of e.messages)t.images&&(t.images=await Promise.all(t.images.map(this.encodeImage.bind(this))));return this.processStreamableRequest("chat",e)}async create(e){return this.processStreamableRequest("create",{name:e.model,stream:e.stream,modelfile:e.modelfile,quantize:e.quantize})}async pull(e){return this.processStreamableRequest("pull",{name:e.model,stream:e.stream,insecure:e.insecure})}async push(e){return this.processStreamableRequest("push",{name:e.model,stream:e.stream,insecure:e.insecure})}async delete(e){return await(async(e,t,r)=>{const n=await x(e,t,{method:"DELETE",body:JSON.stringify(r)});return await k(n),n})(this.fetch,`${this.config.host}/api/delete`,{name:e.model}),{status:"success"}}async copy(e){return await O(this.fetch,`${this.config.host}/api/copy`,{...e}),{status:"success"}}async list(){const e=await N(this.fetch,`${this.config.host}/api/tags`);return await e.json()}async show(e){const t=await O(this.fetch,`${this.config.host}/api/show`,{...e});return await t.json()}async embed(e){const t=await O(this.fetch,`${this.config.host}/api/embed`,{...e});return await t.json()}async embeddings(e){const t=await O(this.fetch,`${this.config.host}/api/embeddings`,{...e});return await t.json()}async ps(){const e=await N(this.fetch,`${this.config.host}/api/ps`);return await e.json()}};const F=new D;export{D as Ollama,F as default};
